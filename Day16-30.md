# Java學習筆記day16-30

# Part 7: 專案實作回顧 (Day 16)

---

## Day 16: 專案討論與架構重構

*(本日為專案實作與討論日，重點在於 MVC 架構的整合與除錯)*

### 1. 核心觀念 (Key Concepts)
- **MVC 架構總結**：
    - **Model**: 資料物件 (`Student`)，不含邏輯，純 POJO。
    - **View**: 介面 (`StudentUI`)，負責輸入輸出，透過 Service 與後端溝通。
    - **Controller (Service)**: 邏輯控制 (`StudentService`)，負責驗證資料、流程控制。
    - **DAO**: 資料存取 (`StudentDao`)，負責 SQL 操作。
- **重構 (Refactoring)**：在不改變程式功能的前提下，優化程式碼結構（例如將重複的 SQL 連線邏輯抽出到 `Tool` 類別）。

### 2. 專案開發流程
1.  **需求分析**：確定要做的功能（新增、查詢、修改、刪除學員成績）。
2.  **資料庫設計**：建立 `school` 資料庫與 `student` 表格。
3.  **Model 建立**：撰寫 `Student.java`。
4.  **DAO 實作**：撰寫 `StudentDaoImpl.java` (CRUD)。
5.  **Service 實作**：撰寫 `StudentServiceImpl.java` (商業邏輯)。
6.  **View 實作**：撰寫 `StudentUI.java` (Swing 介面)。
7.  **整合測試**：串接各層級並進行測試。

---

# Part 8: 進階語法特性 (Day 17 - Day 18)

## Day 17: 內部類別與列舉 (Inner Classes & Enum)

### 1. 核心觀念 (Key Concepts)
- **內部類別 (Inner Class)**：定義在另一個類別內部的類別。
    - **成員內部類別**：需依賴外部物件 (`new Outer().new Inner()`)。
    - **靜態內部類別**：不需外部物件 (`new Outer.Inner()`)。
- **列舉 (Enum)**：
    - 定義**固定常數集合**的特殊類別 (如月份、星期)。
    - 類型安全，比 `int` 常數更好維護。
    - Enum 可以有建構子、欄位與方法。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)
- **Enum 建構子**：必須是 `private`，不能在外部 `new`。
- **內部類別存取**：成員內部類別可以存取外部類別的 `private` 成員，但靜態內部類別只能存取外部的 `static` 成員。

### 3. 本日新增語法 (New Syntax)
| 語法 | 說明 |
| :--- | :--- |
| `class Outer { class Inner {} }` | 成員內部類別 |
| `class Outer { static class Inner {} }` | 靜態內部類別 |
| `enum Name { A, B, C }` | 定義列舉 |
| `Enum.values()` | 取得所有列舉值陣列 |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (包含 Ex2.java, Ex3.java, Ex4.java, Ex5.java, Ex6.java)**：

```java
// [Ex2, Ex3] 內部類別
class School1 {
    void show() { System.out.println("School show"); }
    
    // 成員內部類別
    class A {
        void showA() { System.out.println("Inner A show"); }
    }
    
    // 靜態內部類別
    static class B {
        static void showB() { System.out.println("Static Inner B show"); }
    }
}

// [Ex6] 列舉 (Enum) - Java 7+ 進階用法
enum Book {
    // 定義常數並呼叫建構子
    Java11(600, 10), 
    JavaWeb(700, 5), 
    Spring(800, 20);

    // Enum 的成員變數
    private double price;
    private int amount;

    // 建構子 (預設 private)
    private Book(double price, int amount) {
        this.price = price;
        this.amount = amount;
    }

    public double getPrice() { return price; }
}

class Day17_Demo {
    public static void main(String[] args) {
        // [內部類別實體化]
        // 1. 成員內部類別：需先有外部物件
        School1.A a1 = new School1().new A();
        a1.showA();

        // 2. 靜態內部類別：直接存取
        School1.B.showB();

        // [Enum 實戰]
        // values() 回傳列舉陣列
        for(Book b : Book.values()) {
            System.out.println("書名:" + b + "\t價格:" + b.getPrice());
        }
    }
}
```

---

## Day 18: 匿名內部類別與 Lambda (Anonymous & Lambda)

### 1. 核心觀念 (Key Concepts)
- **匿名內部類別 (Anonymous Inner Class)**：
    - 沒有名字的類別，適合**一次性**實作介面或繼承類別。
    - 語法：`new Interface() { ...實作... };`。
- **Lambda 表達式** (Java 8+)：
    - 簡化匿名內部類別，針對 **Functional Interface** (只有一個抽象方法的介面)。
    - 語法：`(參數) -> { 程式碼 }`。
- **方法參考 (Method Reference)**：
    - `Class::method`，當 Lambda 只是轉呼叫現有方法時可使用。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)
- **介面 new**：看到 `new Interface() {...}` 以為介面可以被 new，其實是產生了一個實作該介面的匿名子類別物件。
- **Lambda 限制**：只能用於只有**一個**抽象方法的介面。若介面有多個方法，必須用傳統匿名類別。

### 3. 本日新增語法 (New Syntax)
| 語法 | 說明 |
| :--- | :--- |
| `new Interface() { ... }` | 匿名內部類別 |
| `(args) -> expression` | Lambda 表達式 |
| `Class::method` | 方法參考 |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (包含 Ex1.java, Ex2.java, Ex3.java, Ex4.java, Ex5.java, Ex6.java, Ex7.java)**：

```java
// 定義 Functional Interface
interface BookStyle {
    String bookStore(String name, double price);
}

// 用於方法參考的類別
class Ca1 {
    static String p2(String name, double price) {
        return "特價書:" + name + " 價錢:" + (price * 0.8);
    }
}

class Day18_Demo {
    public static void main(String[] args) {
        // 1. [傳統匿名內部類別]
        BookStyle b1 = new BookStyle() {
            @Override
            public String bookStore(String name, double price) {
                return "書名:" + name + "\t原價:" + price;
            }
        };
        System.out.println(b1.bookStore("Java", 1000));

        // 2. [Lambda 表達式] (Java 8+)
        // 省略介面名與方法名，直接寫邏輯
        BookStyle b2 = (name, price) -> "書名:" + name + "\tLambda價:" + (price * 0.9);
        System.out.println(b2.bookStore("Python", 1000));

        // 3. [Lambda 區塊寫法] (多行邏輯需加 {})
        BookStyle b3 = (name, price) -> {
            if(price >= 2000) return name + " 8折: " + (price * 0.8);
            else return name + " 原價: " + price;
        };
        System.out.println(b3.bookStore("C++", 2500));

        // 4. [方法參考] (Method Reference)
        // 直接引用 Ca1 類別中已寫好的 p2 方法
        BookStyle b4 = Ca1::p2;
        System.out.println(b4.bookStore("Go", 1000));
    }
}
```

---

# Part 9: 集合框架與資料 I/O (Day 19 - Day 20)

---

## Day 19: 集合框架基礎 (List, Set, Map, Queue)

### 1. 核心觀念 (Key Concepts)
- **集合框架 (Collections Framework)**：Java 用來儲存物件群組的標準架構，位於 `java.util`。
    - 特性：長度可變，只能儲存物件 (Primitive type 需用 Wrapper class)。
- **四大介面**：
    - **List (序列)**：**有序、可重複**。實作：`ArrayList` (查詢快、增刪慢), `LinkedList` (查詢慢、增刪快)。
    - **Set (集)**：**無序、不可重複**。實作：`HashSet` (雜湊表), `TreeSet` (自動排序)。
    - **Map (映射)**：**鍵值對 (Key-Value)**。Key 不可重複，Value 可重複。實作：`HashMap`, `TreeMap`。
    - **Queue (佇列)**：先進先出 (FIFO) 或優先權排序。實作：`PriorityQueue`。
- **泛型 (Generics)**：`List<String>`，指定集合內只能放特定型別，提升型別安全性。
- **排序 (Sorting)**：
    - `TreeSet` / `TreeMap` / `PriorityQueue` 會依據內容自動排序。
    - 自訂物件 (如 `Student`) 若要放入排序集合，**必須實作 `Comparable` 介面**並覆寫 `compareTo` 方法。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)
- **List vs Array**：Array 長度固定 (`length`)，List 長度可變 (`size()`)。
- **Set 重複判斷**：自訂物件放入 `HashSet` 若沒覆寫 `hashCode()` 與 `equals()`，即使內容相同也會被視為不同物件。
- **TreeSet 報錯**：將沒有實作 `Comparable` 的物件放入 `TreeSet`，執行時會拋出 `ClassCastException`。

### 3. 本日新增語法 (New Syntax)
| 語法 | 說明 |
| :--- | :--- |
| `ArrayList<T> list = new ArrayList<>();` | 建立 List |
| `HashSet<T> set = new HashSet<>();` | 建立 Set |
| `HashMap<K,V> map = new HashMap<>();` | 建立 Map |
| `list.add(obj)`, `list.get(index)` | List 操作 |
| `map.put(key, value)`, `map.get(key)` | Map 操作 |
| `class A implements Comparable<A>` | 實作排序介面 |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (包含 ArrayListEx.java, HashSetEx.java, TreeSetEx.java, MapEx.java, Student.java)**：

```java
import java.util.*;

// [Student.java] 實作 Comparable 以支援 TreeSet 排序
class Student implements Comparable<Student> {
    String name;
    int score;
    
    Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    String show() { return name + ":" + score; }

    // 定義排序規則：分數由高到低
    @Override
    public int compareTo(Student o) {
        return o.score - this.score; 
    }
}

class Day19_Collections_Demo {
    public static void main(String[] args) {
        // 1. [List] 有序、可重複
        List<Integer> list = new ArrayList<>();
        list.add(10);
        list.add(10); // 重複 OK
        list.add(30);
        System.out.println("List: " + list); // [10, 10, 30]

        // 2. [Set] 無序、不可重複
        Set<Integer> set = new HashSet<>();
        set.add(10);
        set.add(10); // 重複被忽略
        set.add(30);
        System.out.println("Set: " + set); // [30, 10] (順序不保證)

        // 3. [TreeSet] 自動排序
        Set<Student> tree = new TreeSet<>();
        tree.add(new Student("Andy", 80));
        tree.add(new Student("Bob", 90)); // Bob 分數高，排前面
        
        System.out.println("TreeSet (依分數排序):");
        for(Student s : tree) {
            System.out.println(s.show()); // Bob -> Andy
        }

        // 4. [Map] Key-Value
        Map<String, Integer> map = new HashMap<>();
        map.put("Java", 100);
        map.put("Python", 90);
        System.out.println("Java score: " + map.get("Java")); // 100
    }
}
```

---

## Day 20: 檔案 I/O 與序列化 (File I/O & Serialization)

### 1. 核心觀念 (Key Concepts)
- **I/O 串流 (Stream)**：
    - **Byte Stream**：處理二進位 (e.g., `FileInputStream`, `ObjectInputStream`)。
    - **Character Stream**：處理文字 (e.g., `FileReader`, `BufferedReader`)。
- **File 類別**：管理檔案路徑、建立刪除，不負責讀寫內容。
- **序列化 (Serialization)**：
    - 將物件狀態轉為位元組串流以存檔 (`ObjectOutputStream`)。
    - 物件類別必須實作 `Serializable` 介面 (標記介面，無方法)。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)
- **忘記關閉串流**：I/O 使用完畢務必 `.close()`，或使用 `try-with-resources`。
- **NotSerializableException**：物件要存檔卻沒實作 `Serializable`。
- **亂碼**：Byte Stream 讀取中文字若沒指定編碼轉型，易出現亂碼。

### 3. 本日新增語法 (New Syntax)
| 語法 | 說明 |
| :--- | :--- |
| `new File("path")` | 建立檔案物件 |
| `new FileInputStream(file)` | 讀取檔案 (Byte) |
| `new FileReader(file)` | 讀取檔案 (Char) |
| `implements Serializable` | 允許物件序列化 |
| `new ObjectOutputStream(out)` | 物件輸出串流 |
| `oos.writeObject(obj)` | 寫入物件 |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (包含 FileEx.java, FileReaderEx.java, ObjectOutputStreamEx.java, Student.java)**：

```java
import java.io.*;

// [Student.java] 實作 Serializable
class Student implements Serializable {
    private static final long serialVersionUID = 1L; // 版本號
    String name;
    int score;
    Student(String name, int score) { this.name = name; this.score = score; }
    String show() { return name + ":" + score; }
}

class Day20_IO_Demo {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        String path = "c:/ABC/test.txt";
        String objPath = "c:/ABC/student.ser";
        
        // 1. [File] 建立目錄與檔案
        File f = new File(path);
        if (!f.exists()) {
            f.getParentFile().mkdirs(); // 建立目錄
            f.createNewFile();          // 建立檔案
        }

        // 2. [FileReader] 讀取文字
        try (FileReader fr = new FileReader(path)) {
            int i;
            while ((i = fr.read()) != -1) {
                System.out.print((char) i);
            }
        }

        // 3. [Object I/O] 物件存取
        // 寫入
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(objPath))) {
            oos.writeObject(new Student("Alice", 95));
        }
        // 讀取
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(objPath))) {
            Student s = (Student) ois.readObject();
            System.out.println("讀取物件: " + s.show());
        }
    }
}
```

---

## Day 20-1: 綜合實戰 - 訂單系統 I/O 整合 (GUI + Serialization)

### 1. 專案說明
結合 **Swing GUI** 與 **Object I/O**，實作一個簡單的訂單系統。
- **LoginUI**: 登入視窗，驗證後開啟主程式。
- **OrderUI**: 訂單輸入視窗，將 `Order` 物件序列化存入 `Order.txt`。
- **OrderDetailUI**: 顯示視窗，從 `Order.txt` 讀取並還原物件顯示。

### 2. 核心代碼解析 (Code Analysis)

**A. 資料模型 (Model) - `Order.java`**
```java
// 必須實作 Serializable 才能被寫入檔案
public class Order implements Serializable {
    private String name;
    private int lcd, ram, sum;
    
    public Order(String name, int lcd, int ram) {
        this.name = name;
        this.lcd = lcd;
        this.ram = ram;
        this.sum = lcd * 4900 + ram * 1280;
    }
    // Getter/Setter 省略...
}
```

**B. 登入視窗 (View) - `LoginUI.java`**
```java
// 簡單的帳號密碼驗證
btnNewButton.addMouseListener(new MouseAdapter() {
    public void mouseClicked(MouseEvent e) {
        if(username.getText().equals("abc") && password.getText().equals("123")) {
            // 登入成功，開啟 OrderUI，關閉自己
            OrderUI orderFrame = new OrderUI();
            orderFrame.setVisible(true);
            dispose();
        } else {
            // 錯誤處理 (可加 JLabel 顯示)
            System.out.println("Login Failed");
        }
    }
});
```

**C. 訂單存檔 (Controller/IO) - `OrderUI.java`**
```java
// 按下「確定」後，將資料存檔
btnNewButton.addMouseListener(new MouseAdapter() {
    public void mouseClicked(MouseEvent e) {
        String Name = name.getText();
        int Lcd = Integer.parseInt(lcd.getText());
        int Ram = Integer.parseInt(ram.getText());
        
        // 1. 建立物件
        Order o = new Order(Name, Lcd, Ram);
        
        // 2. 序列化寫入檔案 (覆蓋模式)
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("Order.txt"))) {
            oos.writeObject(o); // 寫入物件
        } catch (IOException ex) {
            ex.printStackTrace();
        }
        
        // 3. 切換到明細頁面
        OrderDetailUI detail = new OrderDetailUI();
        detail.setVisible(true);
        dispose();
    }
});
```

**D. 訂單讀取 (View/IO) - `OrderDetailUI.java`**
```java
// 在建構子或事件中讀取檔案
public OrderDetailUI() {
    // ... UI 初始化 ...
    
    // 讀取物件並顯示
    try (ObjectInputStream ois = new ObjectInputStream(
            new FileInputStream("Order.txt"))) {
        
        Order o = (Order) ois.readObject(); // 還原物件
        
        // 將資料顯示在 TextArea
        textArea.setText(
            "名: " + o.getName() + 
            "\n總額: " + o.getSum()
        );
        
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
# Part 10: 進階整合實戰 - IO, JDBC 與多執行緒 (Day 21)

---

## Day 21: 資料持久化與 GUI 整合

### 1. 核心觀念 (Key Concepts)

#### A. I/O 串流 (Input/Output Stream)
- **串流 (Stream)**：資料傳輸的通道。
- **分類**：
    - **Byte Stream (位元組串流)**：處理二進位資料 (如圖片、序列化物件)，類別以 `Stream` 結尾 (e.g., `FileInputStream`, `ObjectOutputStream`)。
    - **Character Stream (字元串流)**：處理文字資料，類別以 `Reader`/`Writer` 結尾 (e.g., `FileReader`, `FileWriter`)。
- **序列化 (Serialization)**：將物件狀態轉換為位元組串流以進行儲存或傳輸。物件需實作 `Serializable` 介面。

#### B. JDBC (Java Database Connectivity)
- **JDBC API**：Java 連接資料庫的標準介面。
- **核心介面**：
    - `Connection`：建立與資料庫的連線。
    - `PreparedStatement`：預編譯 SQL 指令，可防止 SQL Injection。
    - `ResultSet`：儲存查詢結果的表格。
- **操作步驟**：載入驅動 -> 建立連線 -> 建立語句 -> 執行 SQL -> 處理結果 -> 關閉資源。

#### C. 多執行緒 (Multithreading)
- **執行緒 (Thread)**：程式中獨立執行的路徑。
- **建立方式**：
    1. 繼承 `Thread` 類別，覆寫 `run()`。
    2. 實作 `Runnable` 介面，實作 `run()` (推薦，因可繼承其他類別)。
- **生命週期**：New -> Runnable -> Running -> Blocked/Waiting -> Terminated。
- **同步 (Synchronization)**：使用 `synchronized` 關鍵字防止多執行緒同時存取同一資源導致資料錯誤 (Race Condition)。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)
- **SQL Index 錯誤**：JDBC 的參數索引 (`?`) 是從 **1** 開始，不是 0。
- **ResultSet 游標**：執行查詢後，必須先呼叫 `rs.next()` 將游標移到第一筆資料，否則會報錯。
- **執行緒啟動**：必須呼叫 `.start()` 才會啟動新執行緒；若呼叫 `.run()` 只是在當前執行緒執行普通方法。
- **I/O 關閉**：忘記關閉串流可能導致檔案被鎖定或資源耗盡。

### 3. 本日新增語法 (New Syntax)
| 語法 | 說明 |
| :--- | :--- |
| `Class.forName("driver")` | 載入 JDBC 驅動 |
| `DriverManager.getConnection()` | 取得資料庫連線 |
| `conn.prepareStatement(sql)` | 建立預編譯語句 |
| `ps.executeUpdate()` | 執行增刪改 (回傳影響筆數) |
| `ps.executeQuery()` | 執行查詢 (回傳 ResultSet) |
| `class T extends Thread` | 繼承執行緒類別 |
| `implements Runnable` | 實作執行緒介面 |
| `new Thread(runnable).start()` | 啟動執行緒 |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (包含 JDBC CRUD, I/O Serialization, Threading)**：

```java
import java.sql.*;
import java.io.*;
import java.util.*;

// [Student.java] Model: 同時支援 JDBC 與 Serialization
class Student implements Serializable {
    private String name;
    private int score;
    // ... 建構子與 Getter/Setter ...
    String show() { return name + ":" + score; }
}

// [DbConnection.java] 工具類：取得連線
class DbConnection {
    public static Connection getDb() {
        String url = "jdbc:mysql://localhost:3306/school";
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            return DriverManager.getConnection(url, "root", "1234");
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}

// [JDBC CRUD] 資料庫操作實戰
class JdbcDemo {
    public static void main(String[] args) {
        Connection conn = DbConnection.getDb();
        
        // 1. 新增 (Insert)
        String insertSql = "INSERT INTO student(name, score) VALUES(?, ?)";
        try {
            PreparedStatement ps = conn.prepareStatement(insertSql);
            ps.setString(1, "Andy");
            ps.setInt(2, 90);
            ps.executeUpdate();
            System.out.println("新增成功");
        } catch (SQLException e) { e.printStackTrace(); }

        // 2. 查詢 (Select)
        String selectSql = "SELECT * FROM student";
        try {
            PreparedStatement ps = conn.prepareStatement(selectSql);
            ResultSet rs = ps.executeQuery();
            while(rs.next()) {
                System.out.println(
                    "ID:" + rs.getInt("id") + 
                    "\tName:" + rs.getString("name")
                );
            }
        } catch (SQLException e) { e.printStackTrace(); }
    }
}

// [Threading] 多執行緒實戰
// 模擬公車座位搶票
class Bus implements Runnable {
    private int seat = 10; // 共享資源
    
    // 同步方法：一次只允許一個執行緒進入
    synchronized void booking() {
        if(seat > 0) {
            try { Thread.sleep(100); } catch (Exception e) {} // 模擬延遲
            System.out.println(Thread.currentThread().getName() + " 訂位成功, 剩餘:" + (--seat));
        } else {
            System.out.println("沒位子了");
        }
    }

    @Override
    public void run() {
        while(seat > 0) booking();
    }
}

class ThreadDemo {
    public static void main(String[] args) {
        Bus bus = new Bus();
        // 建立三個執行緒 (三個使用者) 搶同一個 Bus 物件的資源
        Thread t1 = new Thread(bus, "User A");
        Thread t2 = new Thread(bus, "User B");
        Thread t3 = new Thread(bus, "User C");
        
        t1.start();
        t2.start();
        t3.start();
    }
}

// [IO + GUI] 綜合實戰 (Login -> Order -> File)
// (此處為虛擬碼邏輯整合，實際執行需配合 GUI 元件)

class OrderSystem {
    void login(String user, String pass) {
        if(check(user, pass)) openOrderUI();
    }
    
    void saveOrder(Order o) {
        // 使用 ObjectOutputStream 將訂單物件寫入檔案
        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("order.txt"))) {
            oos.writeObject(o);
        } catch(IOException e) {}
    }
    
    void readOrder() {
        // 使用 ObjectInputStream 讀取訂單
        try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream("order.txt"))) {
            Order o = (Order) ois.readObject();
            ui.show(o);
        } catch(Exception e) {}
    }
}

```
# Part 11: JDBC 與 MVC 架構基礎 (Day 22 - Day 24)

---

## Day 22: JDBC 基礎操作 (CRUD)

### 1. 核心觀念 (Key Concepts)

- **JDBC (Java Database Connectivity)**：
    - Java 程式與資料庫溝通的標準 API。
    - 允許 Java 應用程式執行 SQL 語句。

- **DriverManager**：
    - 管理 JDBC 驅動程式。
    - 負責建立與資料庫的連線 (`Connection`)。

- **Connection**：
    - 代表一個與特定資料庫的連線階段 (Session)。
    - 所有 SQL 操作都必須在此連線的基礎上進行。

- **PreparedStatement**：
    - 繼承自 `Statement` 介面。
    - 使用 `?` 作為參數佔位符 (Placeholder)。
    - **優點**：
        1.  **預編譯 (Precompilation)**：資料庫會預先編譯 SQL 結構，執行效能較佳（特別是重複執行時）。
        2.  **安全性 (Security)**：可有效防止 SQL Injection (SQL 注入) 攻擊。

- **CRUD 操作**：
    - **C**reate (新增)：`INSERT`
    - **R**ead (查詢)：`SELECT`
    - **U**pdate (修改)：`UPDATE`
    - **D**elete (刪除)：`DELETE`

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)

- **SQL 索引 (Index)**：JDBC 中 `setInt(1, val)`、`setString(2, val)` 的索引是從 **1** 開始，而不是像陣列從 0 開始。
- **資源釋放**：資料庫連線是有限且昂貴的資源，操作完畢後務必呼叫 `close()` 關閉。實務上建議使用 Try-with-resources 或 `finally` 區塊確保關閉。
- **驅動載入**：雖然 JDBC 4.0 以後可自動載入驅動，但明確寫出 `Class.forName()` 可確保驅動類別被初始化，相容性較佳。
- **SQL 語法**：在 Java 字串中寫 SQL 時，字串結尾**不需要**加分號 (`;`)。例如 `"SELECT * FROM table"` 即可。

### 3. 本日新增語法 (New Syntax)

| 語法 | 說明 |
| :--- | :--- |
| `Class.forName("com.mysql.cj.jdbc.Driver")` | 載入 MySQL JDBC 驅動程式 |
| `DriverManager.getConnection(url, user, pwd)` | 取得資料庫連線 |
| `conn.prepareStatement(sql)` | 建立預編譯 SQL 執行物件 |
| `ps.setInt(index, val)` | 設定第 index 個 `?` 為整數 val |
| `ps.setString(index, str)` | 設定第 index 個 `?` 為字串 str |
| `ps.executeUpdate()` | 執行異動 (Insert/Update/Delete)，回傳 int (影響筆數) |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (包含 DbConnection.java, AddEx2.java, UpdateEx2.java, DeleteEx2.java)**：

```java
import java.sql.*;

// [DbConnection.java] 連線工具類 (封裝連線邏輯)
class DbConnection {
    public static Connection getDb() {
        // JDBC URL 格式: jdbc:mysql://主機:埠號/資料庫名
        String url = "jdbc:mysql://localhost:3306/school";
        String user = "root";
        String password = "1234"; // 請依實際設定修改
        try {
            // 1. 載入驅動
            Class.forName("com.mysql.cj.jdbc.Driver");
            // 2. 建立連線
            return DriverManager.getConnection(url, user, password);
        } catch (Exception e) {
            e.printStackTrace();
            return null; // 連線失敗回傳 null
        }
    }
}

class Day22_JDBC_Demo {
    public static void main(String[] args) {
        Connection conn = DbConnection.getDb();
        if(conn == null) {
            System.out.println("連線失敗");
            return;
        }

        try {
            // 1. [新增 Create] (AddEx2.java)
            // SQL 語句使用 ? 作為佔位符
            String sqlInsert = "INSERT INTO student(name, chi, eng) VALUES(?, ?, ?)";
            PreparedStatement ps1 = conn.prepareStatement(sqlInsert);
            
            // 填入參數 (索引從 1 開始)
            ps1.setString(1, "TestUser");
            ps1.setInt(2, 80);
            ps1.setInt(3, 90);
            
            // 執行更新，回傳影響筆數
            int row = ps1.executeUpdate();
            System.out.println("新增成功，影響筆數: " + row);

            // 2. [修改 Update] (UpdateEx2.java)
            String sqlUpdate = "UPDATE student SET name=?, chi=?, eng=? WHERE id=?";
            PreparedStatement ps2 = conn.prepareStatement(sqlUpdate);
            
            ps2.setString(1, "UpdatedName");
            ps2.setInt(2, 60);
            ps2.setInt(3, 60);
            ps2.setInt(4, 1); // 假設要修改 ID=1 的資料
            
            ps2.executeUpdate();
            System.out.println("修改成功");

            // 3. [刪除 Delete] (DeleteEx2.java)
            String sqlDelete = "DELETE FROM student WHERE id=?";
            PreparedStatement ps3 = conn.prepareStatement(sqlDelete);
            
            ps3.setInt(1, 4); // 假設要刪除 ID=4 的資料
            
            ps3.executeUpdate();
            System.out.println("刪除成功");

        } catch (SQLException e) {
            e.printStackTrace(); // 印出 SQL 錯誤訊息
        }
    }
}
```

---

## Day 23: 查詢與 DAO 模式 (Select & DAO Pattern)

### 1. 核心觀念 (Key Concepts)

- **ResultSet (結果集)**：
    - `executeQuery()` 方法的回傳值，代表 SQL 查詢的結果表格。
    - 具有指向當前資料列的**游標 (Cursor)**，初始位置在第一筆資料**之前** (Before First)。
    - **常用方法**：
        - `next()`：將游標移動到下一列，若有資料回傳 `true`，否則回傳 `false`。
        - `getInt(colLabel)` / `getString(colLabel)`：取出指定欄位的值。

- **DAO (Data Access Object) 模式**：
    - **目的**：將資料存取邏輯 (JDBC Code) 獨立封裝，讓上層的商業邏輯 (Service) 不需要直接處理 SQL。
    - **組成**：
        - **Interface (介面)**：定義資料操作的規範 (如 `add`, `update`, `selectAll`)。
        - **Implementation (實作)**：實作介面，撰寫具體的 JDBC 程式碼。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)

- **游標位置**：取得 `ResultSet` 後**不能直接取值**，必須先呼叫 `next()` 將游標移到第一筆資料。若直接 `getInt()` 會拋出 `SQLException: Before start of result set`。
- **欄位名稱**：`getInt("id")` 括號內的字串必須對應資料庫 Table 的欄位名稱（通常不分大小寫，但建議一致）。
- **迴圈遍歷**：查詢結果通常不只一筆，需配合 `while(rs.next())` 迴圈來遍歷所有資料。

### 3. 本日新增語法 (New Syntax)

| 語法 | 說明 |
| :--- | :--- |
| `ResultSet rs = ps.executeQuery()` | 執行查詢 (Select) |
| `while(rs.next()) { ... }` | 遍歷結果集 |
| `rs.getInt("column_name")` | 取得整數欄位值 |
| `List<Student> list = new ArrayList<>();` | 建立 List 儲存查詢回來的多筆物件 |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (包含 SelectEx2.java, StudentDaoImpl.java)**：

```java
import java.sql.*;
import java.util.*;

// [StudentDaoImpl.java] DAO 實作查詢
// 職責：將資料庫的 Relational Data (表格) 轉換為 Java 的 Object (物件) -> ORM 概念
public class StudentDaoImpl implements StudentDao {
    private Connection conn = Tool.getDb(); // 使用 Day 23 的 Tool 類別取得連線

    @Override
    public List<Student> selectAll2() {
        String sql = "SELECT * FROM student";
        List<Student> list = new ArrayList<>();
        
        try {
            PreparedStatement ps = conn.prepareStatement(sql);
            ResultSet rs = ps.executeQuery();

            while(rs.next()) {
                Student s = new Student();
                // 從 ResultSet 取值並注入到物件中
                s.setId(rs.getInt("id"));
                s.setName(rs.getString("name"));
                s.setChi(rs.getInt("chi"));
                s.setEng(rs.getInt("eng"));
                
                // 將包裝好的物件加入 List
                list.add(s);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return list; // 回傳 List 給 Service
    }
}
```

---

## Day 24: MVC 完整架構實作 (Student Project)

### 1. 核心觀念 (Key Concepts)

- **MVC 架構 (Model-View-Controller)**：
    - **Model (模型)**：`model.Student`。純資料物件 (POJO)，負責攜帶資料，對應資料庫表格結構。
    - **View (視圖)**：`controller.StudentUI`。負責圖形介面顯示、接收使用者輸入與觸發事件。
    - **Controller/Service (控制器/服務)**：`service.StudentServiceImpl`。系統的核心大腦，負責商業邏輯審核、流程控制、呼叫 DAO。

- **分層依賴原則 (Layered Architecture)**：
    - View -> Service -> DAO -> Database。
    - **禁止越級**：View 不應該直接認識或呼叫 DAO，必須透過 Service。
    - **職責單一**：Service 不寫 SQL，DAO 不做邏輯判斷。

- **介面編程 (Program to Interface)**：
    - 使用 `StudentService` 介面來宣告變數，而非直接使用 `StudentServiceImpl` 實作類別。這能增加系統的彈性與可測試性。

### 2. 專案結構 (Project Structure)

```
src
 ├── model            (Student.java - 資料物件)
 ├── dao              (StudentDao.java - 資料存取介面)
 │   └── impl         (StudentDaoImpl.java - JDBC 實作)
 ├── service          (StudentService.java - 商業邏輯介面)
 │   └── impl         (StudentServiceImpl.java - 邏輯實作)
 ├── controller       (StudentUI.java - 視窗程式)
 └── util             (Tool.java - 資料庫連線工具)
```

### 3. 實戰代碼解析 (Code Analysis)

**整合範例 (Service 層與 DAO 層的互動)**：

```java
// [1. DAO 層] StudentDaoImpl.java
// 職責：只管執行 SQL 指令，不管分數合不合理
public class StudentDaoImpl implements StudentDao {
    private Connection conn = Tool.getDb(); // 取得連線

    @Override
    public void add(Student s) {
        String sql = "INSERT INTO student(name, chi, eng) VALUES(?, ?, ?)";
        try {
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setString(1, s.getName());
            ps.setInt(2, s.getChi());
            ps.setInt(3, s.getEng());
            ps.executeUpdate();
        } catch (SQLException e) { e.printStackTrace(); }
    }
}

// [2. Service 層] StudentServiceImpl.java
// 職責：商業邏輯審核 (Business Logic)
public class StudentServiceImpl implements StudentService {
    // 依賴 DAO (使用介面或實作類別皆可，建議用介面)
    private StudentDaoImpl dao = new StudentDaoImpl();

    @Override
    public String addStudent(Student s) {
        // [商業邏輯檢查] 分數必須在 0~100 之間
        if (s.getChi() >= 0 && s.getChi() <= 100 && 
            s.getEng() >= 0 && s.getEng() <= 100) {
            
            // 檢查通過 -> 才呼叫 DAO 進行存檔
            dao.add(s); 
            return "新增成功";
        } else {
            // 檢查失敗 -> 退回錯誤訊息
            return "分數需介於 0~100"; 
        }
    }
}

// [3. View 層] StudentUI.java (片段)
// 職責：事件觸發，資料收集
/*
    btnNewButton.addMouseListener(new MouseAdapter() {
        public void mouseClicked(MouseEvent e) {
            // 1. 收集 UI 資料
            String name = addName.getText();
            int chi = Integer.parseInt(addChi.getText());
            int eng = Integer.parseInt(addEng.getText());
            
            // 2. 封裝成 Model 物件
            Student s = new Student(name, chi, eng);

            // 3. 呼叫 Service (取得回傳訊息)
            // UI 只認識 Service，不認識 DAO
            String result = studentService.addStudent(s);
            
            // 4. 顯示結果
            msgLabel.setText(result);
        }
    });
*/
```

---

# Part 12: 進階 MVC 專案與 SQL 關聯 (Day 25 - Day 26)

---

## Day 25: 訂單系統專案 (Gorder) & 視窗互動

### 1. 核心觀念 (Key Concepts)

- **多視窗應用程式 (Multi-Window Application)**：
    - 系統通常由多個 `JFrame` 組成 (如登入頁、主頁、新增頁、修改頁)。
    - **視窗切換**：使用 `setVisible(true)` 顯示新視窗，`dispose()` 關閉舊視窗並釋放資源。

- **資料傳遞 (Data Passing)**：
    - 不同視窗間如何傳遞資料？(例如從列表點選某一筆，跳出修改視窗並帶入資料)
    - 常見方法：
        1.  **建構子傳遞 (Constructor Injection)**：`new EditUI(id)`。
        2.  **靜態變數**：透過 `Tool` 類別的 static 變數暫存。
        3.  **資料庫**：透過 ID 重新查詢資料庫。

- **部分更新 (Partial Update)**：
    - 在修改功能中，若使用者只填寫某個欄位（如只改名字，不改分數），程式應只更新該欄位，其他欄位保持原值。
    - 這需要先查詢出舊資料，再將新輸入覆蓋上去。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)

- **視窗堆疊**：開啟新視窗時忘記關閉舊視窗 (`dispose()`)，導致應用程式開啟大量視窗，佔用記憶體且使用者混淆。
- **資料庫延遲**：視窗切換回來後 (例如新增完回到列表)，若沒重新呼叫 `selectAll()`，表格顯示的仍是舊資料。
- **空值處理**：修改資料時，需判斷輸入框是否為空字串 `""`，避免將空值寫入資料庫或發生轉型錯誤。

### 3. 本日新增語法 (New Syntax)

| 語法 | 說明 |
| :--- | :--- |
| `frame.dispose()` | 關閉視窗並釋放資源 |
| `frame.setVisible(true)` | 顯示視窗 |
| `if(!str.equals(""))` | 判斷字串非空 |
| `list.get(0)` | 取得 List 中的第一筆資料 |

### 4. 實戰代碼解析 (Code Analysis)

**整合範例 (Gorder 系統：新增與修改流程)**：

```java
// [1. 新增功能] AddOrderUI.java
// 負責收集輸入並呼叫 Service
class AddOrderUI extends JFrame {
    // ... UI 元件 ...
    private GorderServiceImpl service = new GorderServiceImpl();

    public AddOrderUI() {
        JButton btnAdd = new JButton("新增");
        btnAdd.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent e) {
                String name = nameField.getText();
                int pen = Integer.parseInt(penField.getText());
                int ruler = Integer.parseInt(rulerField.getText());

                // 呼叫 Service 新增
                service.addGorder(new Gorder(name, pen, ruler));
                
                // 新增完畢，關閉自己，回到主列表並重新顯示
                GorderUI mainUI = new GorderUI();
                mainUI.setVisible(true);
                dispose(); 
            }
        });
    }
}

// [2. 修改功能] EditUI.java
// 展示了「先查詢舊資料」再「部分更新」的邏輯
class EditUI extends JFrame {
    private GorderServiceImpl service = new GorderServiceImpl();

    public EditUI() {
        JButton btnUpdate = new JButton("修改");
        btnUpdate.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent e) {
                int id = Integer.parseInt(updateId.getText());
                
                // 1. [關鍵] 先從資料庫查出該筆訂單的原始資料
                List<Gorder> list = service.findById(id);
                if(list.isEmpty()) return; // 沒這筆資料
                Gorder g = list.get(0); // 取得舊物件
                
                // 2. 擷取輸入
                String name = updateName.getText();
                String penStr = updatePen.getText();
                String rulerStr = updateRuler.getText();

                // 3. 部分更新邏輯 (只更新有填寫的)
                if(!name.equals("")) g.setName(name);
                
                if(!penStr.equals("")) {
                    int pen = Integer.parseInt(penStr);
                    g.setPen(pen);
                }
                
                if(!rulerStr.equals("")) {
                    int ruler = Integer.parseInt(rulerStr);
                    g.setRuler(ruler);
                }

                // 4. 呼叫 Service 執行更新 (傳入的是混合了新舊資料的 g)
                service.updateGorder(g);
            }
        });
    }
}
```

---

## Day 26: SQL 語法與資料庫關聯設計

### 1. 核心觀念 (Key Concepts)

- **SQL (Structured Query Language)**：
    - **DDL (Definition)**：`CREATE TABLE` (建立表格), `DROP TABLE` (刪除表格)。
    - **DML (Manipulation)**：`INSERT` (新增), `UPDATE` (修改), `DELETE` (刪除)。
    - **DQL (Query)**：`SELECT` (查詢)，最複雜也最強大。

- **進階查詢**：
    - **模糊查詢**：使用 `LIKE` 搭配萬用字元 `%` (任意長度) 或 `_` (單一字元)。
    - **範圍查詢**：`BETWEEN value1 AND value2`。
    - **集合查詢**：`IN (val1, val2, ...)`。
    - **空值查詢**：`IS NULL` (判斷欄位是否為空)。

- **聚合與分組**：
    - **聚合函數**：`COUNT` (計數), `SUM` (加總), `AVG` (平均), `MAX` (最大值), `MIN` (最小值)。
    - **分組 (`GROUP BY`)**：依照特定欄位將資料分組統計。
    - **分組過濾 (`HAVING`)**：針對「分組統計後」的結果進行過濾 (例如：找出總銷售額 > 1000 的產品)。

### 2. 新手常弄錯該注意的地方 (Beginner Mistakes)

- **WHERE vs HAVING**：
    - `WHERE`：篩選**原始資料列** (在 `GROUP BY` 之前執行)。
    - `HAVING`：篩選**統計結果** (在 `GROUP BY` 之後執行)。
- **字串引號**：SQL 中的字串值必須用單引號 `'` 包裹，例如 `'Taipei'`。
- **NULL 判斷**：不能用 `= NULL`，必須用 `IS NULL` 或 `IS NOT NULL`。
- **LIKE 效能**：`LIKE '%A'` (前置百分號) 會導致資料庫無法使用索引 (Index)，查詢速度變慢。

### 3. 本日新增語法 (New Syntax) - SQL

| 語法 | 說明 |
| :--- | :--- |
| `SELECT * FROM table` | 查詢所有欄位 |
| `WHERE col LIKE 'A%'` | 查詢 A 開頭的資料 |
| `ORDER BY col DESC` | 依欄位降冪排序 |
| `GROUP BY col` | 依欄位分組 |
| `HAVING count(*) > 5` | 過濾分組結果 |

### 4. 實戰 SQL 解析 (Code Analysis)

**整合範例 (參考 sql語法.sql)**：

```sql
-- [1. 基礎與範圍查詢]
-- 查詢 ID 在 90 到 100 之間的訂單
SELECT * FROM orders WHERE CustomerID BETWEEN 90 AND 100;

-- 查詢特定日期的訂單
SELECT * FROM orders 
WHERE OrderDate >= '1996-07-03' AND OrderDate <= '1996-07-08';

-- [2. 模糊查詢 (Fuzzy Search)]
-- 找出名字包含 'A' 的客戶
SELECT * FROM customers WHERE CustomerName LIKE '%A%';
-- 找出名字是 A 開頭的客戶
SELECT * FROM customers WHERE CustomerName LIKE 'A%';
-- 找出名字第二個字是 a (_代表一個字元)
SELECT * FROM customers WHERE CustomerName LIKE '_a%';

-- [3. 空值處理]
-- 找出沒有填寫 City 的客戶
SELECT * FROM customers WHERE City IS NULL OR City = '';

-- [4. 排除查詢]
-- 找出 City 不是 London 也不是 Madrid 的客戶
SELECT * FROM customers WHERE City NOT IN ('London', 'Madrid');

-- [5. 聚合與分組 (進階)]
-- 統計每個產品 (ProductID) 的銷售狀況
-- 條件：只顯示總銷售量 >= 300 的產品
-- 排序：依銷售總量由大到小
SELECT 
    ProductID,
    COUNT(ProductID) as '訂單筆數',      -- 幾張單
    SUM(Quantity) as '銷售總量',         -- 賣幾個
    MAX(Quantity) as '單筆最大量',
    MIN(Quantity) as '單筆最小量'
FROM order_details
GROUP BY ProductID                       -- 依產品分組
HAVING SUM(Quantity) >= 300              -- 過濾分組結果 (注意這裡是 HAVING)
ORDER BY SUM(Quantity) DESC;             -- 排序
```